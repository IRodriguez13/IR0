IR0 KERNEL - COMPREHENSIVE SUBSYSTEM OVERVIEW AND ARCHITECTURE GUIDE

===============================================================================
1. PROYECTO GENERAL Y ALCANCE
===============================================================================

El IR0 Kernel es un sistema operativo de desarrollo educativo/experimental que
implementa soporte multi-arquitectura con enfoque en diseño modular y limpio.

ARQUITECTURAS SOPORTADAS:
- x86-32 (i386): Completamente funcional, bootea vía GRUB/Multiboot1
- x86-64 (amd64): Completamente funcional, bootea vía GRUB/Multiboot2 
- ARM32: Estructura preparada, toolchain configurado, implementación pendiente
- ARM64: Estructura preparada, toolchain configurado, implementación pendiente

BUILD TARGETS:
- desktop: Configuración completa con VFS, GUI preparada, múltiples schedulers
- server: Similar a desktop, optimizado para cargas de trabajo servidor
- iot: Configuración ligera para dispositivos IoT
- embedded: Configuración mínima para sistemas embebidos

===============================================================================
2. SISTEMA DE BUILD Y MAKEFILE PRINCIPAL
===============================================================================

ESTRUCTURA DEL BUILD SYSTEM:
El Makefile principal en la raíz coordina toda la compilación multi-arquitectura.
Utiliza compilación condicional basada en variables ARCH y BUILD_TARGET.

CARACTERÍSTICAS CLAVE:
- Detección automática de toolchains (gcc nativo, cross-compilers ARM)
- Flags específicos por arquitectura (-m32/-m64, -march=, etc.)
- Limpieza automática antes de cada build para evitar contaminación de objetos
- Generación automática de ISOs bootables por arquitectura
- Soporte para compilación paralela (make -j)

FLUJO DE COMPILACIÓN:
1. Validación de parámetros ARCH y BUILD_TARGET
2. Configuración de flags de compilación específicos
3. Limpieza previa (clean)
4. Compilación de subsistemas en orden de dependencias
5. Enlazado final del kernel
6. Generación de ISO bootable

SUBSISTEMAS COMPILADOS (en orden):
- includes/: Funciones básicas de string y utilidades
- includes/ir0/: Sistema de impresión y funciones básicas del kernel
- includes/ir0/panic/: Sistema de manejo de pánico
- kernel/: Inicialización principal y entry point
- interrupt/: Manejo de interrupciones e IDT
- drivers/timer/: Controladores de temporizadores (PIT, LAPIC, HPET)
- kernel/scheduler/: Múltiples algoritmos de scheduling
- arch/common/: Funciones comunes entre arquitecturas
- memory/: Gestión de memoria física y virtual
- setup/: Configuración del kernel y features
- fs/: Sistema de archivos virtual (VFS)
- arch/<ARCH>/: Código específico de arquitectura

===============================================================================
3. SUBSISTEMA DE MEMORIA (memory/)
===============================================================================

COMPONENTES PRINCIPALES:

3.1 ASIGNADOR FÍSICO (physical_allocator.c):
- Gestiona memoria física usando bitmap
- Tracks páginas libres/ocupadas en chunks de 4KB
- Funciones principales: phys_alloc_page(), phys_free_page()
- Inicialización basada en memory map del bootloader
- Soporte para reserva de regiones críticas del kernel

3.2 ASIGNADOR HEAP (heap_allocator.c):
- Implementa kmalloc() y kfree() para el kernel
- Gestión de chunks de tamaño variable
- Algoritmo first-fit con coalescing de bloques libres
- Headers de chunks para tracking de tamaños
- Debugging integrado para detección de memory leaks

3.3 ASIGNADOR VIRTUAL (vallocator.c):
- vmalloc() para asignación de memoria virtual contigua
- Mapeo bajo demanda de páginas físicas
- Gestión de rangos de direcciones virtuales
- Soporte para diferentes tipos de memoria (cached/uncached)

3.4 PAGINACIÓN ON-DEMAND (ondemand-paging.c):
- Page fault handling inteligente
- Mapeo lazy de páginas
- Copy-on-write (COW) básico
- Swapping primitivo a storage

3.5 ARQUITECTURA ESPECÍFICA:
- x86-32: Paginación de 2 niveles (Page Directory + Page Tables)
- x86-64: Paginación de 4 niveles (PML4 + PDPT + PD + PT)
- Identity mapping de primeros 256MB para estabilidad
- Higher-half kernel mapping preparado

LAYOUT DE MEMORIA:
- Kernel space: 0xC0000000+ (x86-32), 0xFFFFFFFF80000000+ (x86-64)
- User space: 0x00000000-0xBFFFFFFF (x86-32), 0x0000000000000000-0x00007FFFFFFFFFFF (x86-64)
- VMALLOC área: Rango dedicado para asignaciones virtuales
- I/O mapping: Espacios reservados para dispositivos

===============================================================================
4. SUBSISTEMA DE INTERRUPCIONES (interrupt/)
===============================================================================

COMPONENTES:

4.1 IDT (Interrupt Descriptor Table):
- Configuración de 256 entradas de interrupción
- Gates específicos para excepciones de CPU
- Handler genérico para IRQs no implementados
- Soporte dual x86-32/x86-64 con estructuras adaptadas

4.2 MANEJADORES ISR (isr_handlers.c):
- Exception handlers: Page Fault, GPF, Double Fault, etc.
- Timer interrupt handler (simplificado para estabilidad)
- Keyboard/mouse interrupt stubs
- Logging detallado de excepciones para debugging

4.3 ASSEMBLER STUBS (interrupt.asm):
- Entry points de bajo nivel para todas las interrupciones
- Preservación de registros y estado de CPU
- Transición segura entre modo user/kernel
- Stack switching para interrupciones privilegiadas

4.4 PIC INITIALIZATION:
- Configuración del 8259 PIC (master/slave)
- Mapeo de IRQs a vectores de interrupción
- Masking selectivo de interrupciones
- EOI (End of Interrupt) handling

EXCEPCIONES MANEJADAS:
- Division by Zero (Vector 0)
- Debug Exception (Vector 1)  
- Page Fault (Vector 14) - Con análisis detallado de causa
- General Protection Fault (Vector 13)
- Double Fault (Vector 8) - Handler de recuperación
- Invalid Opcode (Vector 6)
- Stack Segment Fault (Vector 12)

===============================================================================
5. SUBSISTEMA DE TEMPORIZADORES (drivers/timer/)
===============================================================================

5.1 PIT (Programmable Interval Timer):
- Timer principal del sistema basado en Intel 8253/8254
- Frecuencia configurable (típicamente 1000 Hz)
- Generación de interrupciones periódicas para scheduling
- Modo square wave para estabilidad
- Calibración automática

5.2 LAPIC (Local Advanced PIC):
- Timer local por CPU core
- Mayor precisión que PIT
- Soporte para SMP (múltiples cores)
- One-shot y periodic modes
- Calibración basada en bus speed

5.3 HPET (High Precision Event Timer):
- Timer de alta precisión (nanosegundos)
- Múltiples comparadores independientes
- 64-bit counters
- Detección automática vía ACPI
- Fallback a PIT si no disponible

5.4 SISTEMA DE SELECCIÓN AUTOMÁTICA:
- Detección de capabilities del hardware
- Priorización: HPET > LAPIC > PIT
- Configuración automática de frecuencias
- Benchmarking para verificar precisión

FUNCIONALIDADES:
- init_clock(): Inicialización automática del mejor timer
- delay_ms(): Delays precisos para debugging
- Tick generation para scheduler
- Timestamp services para profiling

===============================================================================
6. SUBSISTEMA DE SCHEDULING (kernel/scheduler/)
===============================================================================

6.1 COMPLETELY FAIR SCHEDULER (CFS):
- Algoritmo basado en virtual runtime
- Red-black tree para queue de procesos
- Balanceado automático de cargas
- Soporte para nice values y prioridades
- Latencia mínima garantizada

6.2 PRIORITY SCHEDULER:
- Múltiples niveles de prioridad (0-255)
- Round-robin dentro de cada nivel
- Preemption basada en prioridad
- Aging para prevenir starvation
- Real-time tasks support

6.3 ROUND-ROBIN SCHEDULER:
- Time slicing equitativo
- Quantum configurable por proceso
- Context switching eficiente
- Load balancing básico
- Ideal para cargas batch

6.4 DETECCIÓN AUTOMÁTICA:
- Selección de scheduler basada en carga de trabajo
- Métricas de performance en tiempo real
- Switching dinámico entre algoritmos
- Configuración manual override

6.5 CONTEXT SWITCHING:
- Preservación completa de estado de CPU
- FPU/SSE state saving
- Memory mapping switches
- Stack pointer management
- Assembler optimizado por arquitectura

TASK MANAGEMENT:
- Estructura task_t con estado completo
- Process creation/termination
- Signal handling básico
- IPC primitives (semaphores, mutexes)
- Process trees y relationships

===============================================================================
7. SUBSISTEMA DE ARRANQUE Y ARQUITECTURA (arch/)
===============================================================================

7.1 COMMON (arch/common/):
- Funciones compartidas entre arquitecturas
- inb()/outb() para I/O ports
- cpu_wait() para estados de espera
- Architecture detection en runtime
- Abstracciones de hardware común

7.2 x86-32 ESPECÍFICO:
- boot_x86.asm: Multiboot1 entry point
- GDT setup para protected mode
- IDT de 32-bit con estructuras compatibles
- Paging setup de 2 niveles
- Context switching de 32-bit

7.3 x86-64 ESPECÍFICO:
- boot_x64.asm: Multiboot2 entry point  
- Long mode initialization
- 64-bit GDT y IDT structures
- 4-level paging setup
- Extended context (RIP, RSP, etc.)

7.4 EXCEPTION HANDLING:
- Handlers específicos por arquitectura
- Register dumping completo
- Stack trace generation
- Recovery attempts para faults no fatales
- Logging para post-mortem analysis

BOOT SEQUENCE:
1. GRUB carga kernel y ejecuta entry point
2. Bootloader info parsing (memory map, modules)
3. Basic CPU setup (GDT, segments)
4. Memory detection y initialization
5. IDT setup y exception handlers
6. Timer initialization
7. Scheduler startup
8. Transition a stable loop o user mode

===============================================================================
8. SISTEMA DE ARCHIVOS VIRTUAL (fs/)
===============================================================================

8.1 VFS CORE:
- Abstracción universal de filesystems
- inode-based file representation
- Hierarchical directory structure
- Mount point management
- Path resolution con symlinks

8.2 VFS SIMPLE IMPLEMENTATION:
- In-memory filesystem para testing
- Basic file operations (open, close, read, write)
- Directory operations (mkdir, rmdir, ls)
- File metadata (size, permissions, timestamps)
- Simple allocation scheme

OPERACIONES SOPORTADAS:
- vfs_open(): Apertura de archivos con modes
- vfs_close(): Cierre y cleanup
- vfs_read()/vfs_write(): I/O con buffering
- vfs_seek(): Posicionamiento en archivo
- vfs_stat(): Metadata retrieval
- vfs_mkdir()/vfs_rmdir(): Directory operations

FUTURAS EXTENSIONES:
- EXT2/FAT32 filesystem drivers
- Block device abstraction
- Disk I/O scheduling
- Journaling support
- Network filesystems (NFS)

===============================================================================
9. CONFIGURACIÓN Y SETUP (setup/)
===============================================================================

9.1 KERNEL CONFIG:
- Feature flags por build target
- Runtime feature detection
- Configuration printing para debugging
- Conditional compilation support

9.2 BUILD TARGETS:
- DESKTOP: GUI + networking + full VFS + múltiples schedulers
- SERVER: Optimizado para throughput, sin GUI, networking avanzado
- IOT: Footprint mínimo, power management, wireless support
- EMBEDDED: Bare minimum, real-time guarantees, custom hardware

CONFIGURACIONES:
- Memory layouts específicos
- Timer frequencies optimizadas
- Scheduler selection automática
- Device driver inclusion/exclusion
- Debug level configuration

===============================================================================
10. SISTEMA DE DEPURACIÓN Y DIAGNÓSTICO
===============================================================================

10.1 LOGGING SYSTEM:
- print() para output básico a consola
- Niveles de log (ERROR, WARN, INFO, DEBUG)
- Serial output para capture remoto
- Ring buffer para log history
- Timestamp en cada mensaje

10.2 EXCEPTION ANALYSIS:
- Detailed register dumps
- Stack traces con symbol resolution
- Memory state analysis
- Hardware state inspection (CR0, CR4, EFER)
- Exception cause categorization

10.3 DEBUGGING TOOLS:
- delay_ms() para timing de eventos
- Memory dump utilities
- Process state inspection
- Hardware register readers
- QEMU integration hooks

===============================================================================
11. COMANDOS DE BUILD Y EJECUCIÓN
===============================================================================

COMPILACIÓN:
- make clean-all                          # Limpieza total
- make ARCH=x86-32 BUILD_TARGET=desktop   # Build 32-bit desktop
- make ARCH=x86-64 BUILD_TARGET=desktop   # Build 64-bit desktop
- make ARCH=x86-32 BUILD_TARGET=server    # Build 32-bit servidor
- make ARCH=x86-64 BUILD_TARGET=embedded  # Build 64-bit embedded

EJECUCIÓN:
- make ARCH=x86-64 BUILD_TARGET=desktop run   # QEMU con GUI
- qemu-system-x86_64 -cdrom kernel-x86-64-desktop.iso -m 512M
- qemu-system-i386 -cdrom kernel-x86-32-desktop.iso -m 256M

DEBUGGING:
- make ARCH=x86-64 debug                      # QEMU con debug flags
- qemu-system-x86_64 -cdrom <iso> -serial stdio -d int,cpu_reset

===============================================================================
12. ESTADO ACTUAL Y ROADMAP
===============================================================================

ESTADO ACTUAL:
✓ x86-32: Builds, boots, stable loop funcional
✓ x86-64: Builds, boots, stable loop funcional  
✓ Multi-arch build system completamente funcional
✓ Memory management básico operativo
✓ Interrupt handling estable
✓ Timer subsystem inicializado
✓ Scheduler framework presente
△ ARM: Estructura presente, implementación pendiente

PRÓXIMOS HITOS:
1. Reactivar timer → scheduler path completo
2. Implementar task creation y context switching real
3. User mode transition y system calls
4. Complete VFS con filesystem drivers
5. Networking stack básico
6. ARM32/ARM64 bring-up completo
7. SMP support para múltiples cores
8. Advanced memory management (COW, swapping)

LIMITACIONES ACTUALES:
- Stable loop temporal en lugar de scheduling completo
- Timer ISR simplificado para estabilidad inicial  
- ARM architectures sin implementación funcional
- VFS limitado a operaciones básicas
- Sin user mode processes aún

===============================================================================
FINAL - IR0 KERNEL OVERVIEW
===============================================================================
