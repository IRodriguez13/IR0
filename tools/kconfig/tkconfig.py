#!/usr/bin/env python3

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import os
import json
import subprocess
import sys

class KernelConfigGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("IR0 Kernel Configuration")
        self.root.geometry("1000x700")
        self.root.minsize(800, 600)
        
        # Load kernel version
        self.kernel_version = self.get_kernel_version()
        
        # Configuration data
        self.config = {}
        self.load_config()
        
        # Create GUI
        self.setup_ui()
        
        # Load kernel configuration options
        self.load_kernel_options()
    
    def get_kernel_version(self):
        try:
            with open('Makefile', 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('IR0_VERSION_STRING :='):
                        version = line.split('=', 1)[1].strip()
                        return f"v{version}"
        except Exception as e:
            print(f"Error reading kernel version: {e}")
        return "v0.0.1-pre-rc1"
    
    def load_config(self):
        if os.path.exists('.config'):
            try:
                with open('.config', 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            if '=' in line:
                                key, value = line.split('=', 1)
                                self.config[key] = value.strip('\n\r\t ')
            except Exception as e:
                print(f"Error loading config: {e}")
    
    def save_config(self):
        try:
            with open('.config', 'w') as f:
                f.write(f"# IR0 Kernel Configuration\n")
                f.write(f"# Generated by IR0 Kernel Config Tool\n")
                f.write(f"# {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                # Ordenar las opciones para una mejor legibilidad
                sorted_keys = sorted(self.config.keys())
                
                # Escribir las opciones habilitadas (=y) primero
                for key in sorted_keys:
                    if self.config[key] == 'y':
                        f.write(f"{key}=y\n")
                
                # Escribir las opciones con valores específicos
                for key in sorted_keys:
                    if self.config[key] not in ['y', 'n'] and '=' in key:
                        f.write(f"{key}={self.config[key]}\n")
                
                # Escribir las opciones deshabilitadas al final
                for key in sorted_keys:
                    if self.config[key] == 'n':
                        f.write(f"# {key} is not set\n")
            
            # Crear un archivo de configuración para el Makefile
            with open('include/generated/autoconf.h', 'w') as f:
                f.write("/* AUTOGENERATED BY KCONFIG - DO NOT EDIT */\n")
                f.write("#ifndef __AUTOCONF_H__\n")
                f.write("#define __AUTOCONF_H__\n\n")
                
                for key, value in self.config.items():
                    if value == 'y':
                        f.write(f"#define {key} 1\n")
                    elif value == 'n':
                        f.write(f"#undef {key}\n")
                    else:
                        # Para valores que no son booleanos
                        if '=' in key:
                            k, v = key.split('=', 1)
                            f.write(f"#define {k} {v}\n")
                        else:
                            f.write(f"#define {key} \"{value}\"\n")
                
                f.write("\n#endif /* __AUTOCONF_H__ */\n")
            
            messagebox.showinfo("Success", "Configuration saved to .config and include/generated/autoconf.h")
            return True
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save configuration: {e}")
            return False
    
    def load_kernel_options(self):
        # Get build information
        self.kernel_version = self.get_kernel_version()
        self.kernel_build_date = ""
        self.kernel_build_time = ""
        
        try:
            with open('Makefile', 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('IR0_BUILD_DATE :='):
                        self.kernel_build_date = line.split('=', 1)[1].strip()
                    elif line.startswith('IR0_BUILD_TIME :='):
                        self.kernel_build_time = line.split('=', 1)[1].strip()
        except Exception as e:
            print(f"Error reading build info: {e}")
            self.kernel_build_date = "Unknown date"
            self.kernel_build_time = "Unknown time"
        
        # Kernel version information (read-only)
        version_frame = ttk.LabelFrame(self.root, text="Kernel Version", padding=5)
        version_frame.pack(fill='x', padx=5, pady=5)
        
        version_label = ttk.Label(
            version_frame, 
            text=f"IR0 Kernel {self.kernel_version}",
            font=('TkDefaultFont', 10, 'bold')
        )
        version_label.pack(anchor='w')
        
        build_info = f"Build: {self.kernel_build_date} {self.kernel_build_time}"
        build_label = ttk.Label(
            version_frame, 
            text=build_info, 
            font=('TkDefaultFont', 8)
        )
        build_label.pack(anchor='w')
        
        # Configuration options
        self.kernel_options = {
            "General Configuration": {
                "description": "General IR0 Kernel configuration options",
                "options": {
                    "LOCALVERSION": {
                        "type": "string",
                        "prompt": "Local version string",
                        "default": "",
                        "help": "Append an extra string to the end of kernel version"
                    }
                }
            },
            
            "Architecture and Processor": {
                "description": "Processor architecture and features configuration",
                "options": {
                    "ARCH_X86_64": {
                        "type": "bool",
                        "prompt": "x86-64 Architecture",
                        "default": "y",
                        "help": "Enable support for x86-64 architecture"
                    },
                    "ENABLE_SMP": {
                        "type": "bool",
                        "prompt": "Symmetric Multi-Processing (SMP) Support",
                        "default": "n",
                        "help": "Enable support for multiple CPUs"
                    }
                }
            },
            
            "Memory Management": {
                "description": "Memory management configuration options",
                "options": {
                    "ENABLE_BUMP_ALLOCATOR": {
                        "type": "bool",
                        "prompt": "Bump Allocator",
                        "default": "y",
                        "help": "Simple memory allocator (always enabled)"
                    },
                    "ENABLE_HEAP_ALLOCATOR": {
                        "type": "bool",
                        "prompt": "Heap Allocator",
                        "default": "y",
                        "help": "Dynamic memory allocator with free/alloc support"
                    },
                    "ENABLE_PAGING": {
                        "type": "bool",
                        "prompt": "Paging Support",
                        "default": "y",
                        "help": "Enable memory paging support"
                    },
                    "ENABLE_VM": {
                        "type": "bool",
                        "prompt": "Virtual Memory",
                        "default": "y",
                        "help": "Enable virtual memory management"
                    }
                }
            },
            
            "File Systems": {
                "description": "File system configuration options",
                "options": {
                    "ENABLE_VFS": {
                        "type": "bool",
                        "prompt": "Virtual File System (VFS)",
                        "default": "y",
                        "help": "Enables the Virtual File System layer that provides a unified interface \
to access different file system types. VFS acts as an abstraction layer that allows \
the kernel to support multiple file system formats transparently, offering standard \
operations like open(), read(), write(), and close() regardless of the underlying \
file system implementation."
                    },
                    "ENABLE_MINIX_FS": {
                        "type": "bool",
                        "prompt": "MINIX File System",
                        "default": "y",
                        "help": "Enables support for the MINIX file system, one of the first file systems \
used in Unix-like operating systems. This file system is simple yet robust, featuring \
a hierarchical directory structure. It's ideal for embedded devices or systems with \
limited resources due to its low memory footprint and processing overhead."
                    },
                    "ENABLE_RAMDISK": {
                        "type": "bool",
                        "prompt": "RAM Disk Support",
                        "default": "y",
                        "help": "Enables RAM Disk support, which allows using a portion of system RAM as \
a block device. RAM Disks provide extremely fast access times and are useful for \
temporary storage, caching, or during system boot. Note that all data in RAM Disks \
will be lost on system shutdown or reboot."
                    }
                }
            },
            
            "Device Drivers": {
                "description": "System device drivers configuration",
                "options": {
                    "ENABLE_SERIAL_DRIVER": {
                        "type": "bool",
                        "prompt": "Serial Port Driver",
                        "default": "y",
                        "help": "Enable the serial port driver for console output and debugging"
                    },
                    "ENABLE_KEYBOARD_DRIVER": {
                        "type": "bool",
                        "prompt": "Keyboard Driver",
                        "default": "y",
                        "help": "Enable the PS/2 keyboard input driver"
                    },
                    "ENABLE_VGA_DRIVER": {
                        "type": "bool",
                        "prompt": "VGA Video Driver",
                        "default": "y",
                        "help": "Enable the VGA video driver for text-mode display"
                    },
                    "ENABLE_ATA_DRIVER": {
                        "type": "bool",
                        "prompt": "ATA Disk Driver",
                        "default": "y",
                        "help": "Enable the ATA disk driver for hard disk access"
                    }
                }
            },
            
            "Time System": {
                "description": "Timer and clock configuration options",
                "options": {
                    "ENABLE_PIT": {
                        "type": "bool",
                        "prompt": "PIT (Programmable Interval Timer)",
                        "default": "y",
                        "help": "Enable the legacy Programmable Interval Timer for system timing"
                    },
                    "ENABLE_HPET": {
                        "type": "bool",
                        "prompt": "HPET (High Precision Event Timer)",
                        "default": "y",
                        "help": "Enable the High Precision Event Timer for more accurate timing"
                    },
                    "ENABLE_LAPIC": {
                        "type": "bool",
                        "prompt": "Local APIC (Advanced Programmable Interrupt Controller)",
                        "default": "y",
                        "help": "Enable the Local APIC for advanced interrupt handling and timing"
                    }
                }
            },
            
            "Process Scheduler": {
                "description": "Process scheduling configuration",
                "options": {
                    "ENABLE_SCHEDULER": {
                        "type": "bool",
                        "prompt": "Task Scheduler",
                        "default": "y",
                        "help": "Enables the kernel's task scheduler, which determines which runnable process \
should execute next on each CPU. The scheduler is a critical kernel component that directly \
affects system performance, responsiveness, and efficient CPU resource utilization."
                    },
                    "ENABLE_CFS_SCHEDULER": {
                        "type": "bool",
                        "prompt": "CFS Scheduler (Completely Fair Scheduler)",
                        "default": "y",
                        "help": "Enables the Completely Fair Scheduler (CFS), an advanced scheduling algorithm \
that allocates CPU time in proportion to each process's weight (priority), aiming for fair \
CPU usage distribution. This is the recommended scheduler for most general-purpose systems.",
                        "depends": ["ENABLE_SCHEDULER"]
                    },
                    "ENABLE_RR_SCHEDULER": {
                        "type": "bool",
                        "prompt": "Round-Robin Scheduler",
                        "default": "n",
                        "help": "Enables the Round-Robin scheduler which allocates a fixed time slice to each \
process in a circular order. This is a simple and predictable scheduler but may not provide \
optimal performance for interactive tasks.",
                        "depends": ["ENABLE_SCHEDULER"],
                        "disabled_reason": "Not implemented in this kernel version"
                    },
                    "ENABLE_PRIORITY_SCHEDULER": {
                        "type": "bool",
                        "prompt": "Priority Scheduler",
                        "default": "n",
                        "help": "Enables the Priority-based scheduler which executes processes based on their \
assigned priority, with higher priority processes running first. This scheduler is useful \
for real-time systems but requires careful priority assignment.",
                        "depends": ["ENABLE_SCHEDULER"],
                        "disabled_reason": "Not implemented in this kernel version"
                    },
                    "TICK_RATE_HZ": {
                        "type": "int",
                        "prompt": "Timer Frequency (Hz)",
                        "default": "100",
                        "help": "Sets the system timer interrupt frequency in Hertz (Hz). \
Typical values are 100Hz for general-purpose systems, 250Hz or 300Hz for desktop systems \
requiring good responsiveness, and 1000Hz for systems needing low latency. Higher values \
provide better timing granularity but increase system overhead.",
                        "range": [100, 1000],
                        "depends": ["ENABLE_SCHEDULER"]
                    }
                }
            },
            
            "Interrupt System": {
                "description": "Interrupt handling configuration",
                "options": {
                    "ENABLE_PIC": {
                        "type": "bool",
                        "prompt": "Programmable Interrupt Controller (PIC)",
                        "default": "y",
                        "help": "Enable the legacy 8259A Programmable Interrupt Controller"
                    },
                    "ENABLE_APIC": {
                        "type": "bool",
                        "prompt": "Advanced Programmable Interrupt Controller (APIC)",
                        "default": "y",
                        "help": "Enable the Advanced Programmable Interrupt Controller"
                    },
                    "ENABLE_IOAPIC": {
                        "type": "bool",
                        "prompt": "I/O APIC Controller",
                        "default": "y",
                        "help": "Enable the I/O APIC for advanced interrupt routing in multi-processor systems"
                    }
                }
            },
            
            "Debugging and Logging": {
                "description": "System debugging and logging options",
                "options": {
                    "ENABLE_DEBUG": {
                        "type": "bool",
                        "prompt": "Debugging Support",
                        "default": "y",
                        "help": "Enables kernel debugging support, including debug messages, assertion checks, \
and diagnostic functions. This option is essential during development but can be disabled in \
production environments to improve performance and reduce kernel size."
                    },
                    "DEBUG_LEVEL": {
                        "type": "int",
                        "prompt": "Debug Level",
                        "default": "1",
                        "help": "Controls the verbosity of debug messages:\n\
• 0: Critical messages only (system failures)\n\
• 1: Errors and warnings (recommended for production)\n\
• 2: Detailed information (useful for basic debugging)\n\
• 3: Very detailed traces (may affect performance)"
                    },
                    "ENABLE_SERIAL_DEBUG": {
                        "type": "bool",
                        "prompt": "Serial Port Debugging",
                        "default": "y",
                        "help": "Enables sending debug messages through the serial port (UART). This is particularly \
useful for early system boot debugging when other output mechanisms like graphical console \
or logging systems might not be available. Requires a properly configured serial connection."
                    },
                    "ENABLE_ASSERT": {
                        "type": "bool",
                        "prompt": "Debug Assertions",
                        "default": "y",
                        "help": "Enables runtime assertion checks. Assertions verify code assumptions and halt execution \
if these assumptions are not met, helping to detect programming errors during development. \
Recommended: Enable during development, disable in production for better performance."
                    }
                }
            }
        }
        
        # Create tree items
        for category, data in self.kernel_options.items():
            parent = self.tree.insert("", "end", text=category, values=("", ""))
            for option_id, option_data in data["options"].items():
                value = self.config.get(option_id, option_data["default"])
                self.tree.insert(parent, "end", text=option_data["prompt"], 
                               values=(option_id, value))
    
    def on_tree_select(self, event):
        selected = self.tree.selection()
        if not selected:
            return
            
        item = selected[0]
        item_text = self.tree.item(item, "text")
        item_values = self.tree.item(item, "values")
        
        # Clear previous content
        self.details_text.config(state=tk.NORMAL)
        self.details_text.delete(1.0, tk.END)
        
        # If it's a category, show its description
        if not item_values or len(item_values) < 2:
            for category, data in self.kernel_options.items():
                if category == item_text:
                    self.details_text.insert(tk.END, f"{category}\n")
                    self.details_text.insert(tk.END, "=" * len(category) + "\n\n")
                    self.details_text.insert(tk.END, data["description"] + "\n\n")
                    self.details_text.insert(tk.END, "Options in this category:\n")
                    for opt_id, opt_data in data["options"].items():
                        self.details_text.insert(tk.END, f"  • {opt_data['prompt']}\n")
                    break
        else:
            # It's an option, show its details
            option_id = item_values[0]
            for category, data in self.kernel_options.items():
                if option_id in data["options"]:
                    opt_data = data["options"][option_id]
                    self.details_text.insert(tk.END, f"{opt_data['prompt']} ({option_id})\n")
                    self.details_text.insert(tk.END, "=" * (len(opt_data['prompt']) + len(option_id) + 2) + "\n\n")
                    self.details_text.insert(tk.END, f"Type: {opt_data['type']}\n")
                    self.details_text.insert(tk.END, f"Current value: {self.config.get(option_id, opt_data['default'])}\n\n")
                    self.details_text.insert(tk.END, opt_data['help'])
                    break
        
        self.details_text.config(state=tk.DISABLED)
    
    def on_toggle_option(self):
        selected = self.tree.selection()
        if not selected:
            return
            
        item = selected[0]
        item_values = self.tree.item(item, "values")
        
        # Only process if it's an option (has values)
        if item_values and len(item_values) >= 2:
            option_id = item_values[0]
            current_value = item_values[1]
            
            # Find the option in our configuration
            for category, data in self.kernel_options.items():
                if option_id in data["options"]:
                    opt_data = data["options"][option_id]
                    if opt_data["type"] == "bool":
                        new_value = "y" if current_value != "y" else "n"
                        self.config[option_id] = new_value
                        # Update the tree display
                        self.tree.item(item, values=(option_id, new_value))
                        # Update the details view
                        self.on_tree_select(None)
                    break
    
    def on_edit_string(self):
        selected = self.tree.selection()
        if not selected:
            return
            
        item = selected[0]
        item_values = self.tree.item(item, "values")
        
        # Only process if it's an option (has values)
        if item_values and len(item_values) >= 2:
            option_id = item_values[0]
            current_value = item_values[1]
            
            # Find the option in our configuration
            for category, data in self.kernel_options.items():
                if option_id in data["options"] and data["options"][option_id]["type"] == "string":
                    new_value = tk.simpledialog.askstring("Edit Value", 
                        f"Enter value for {data['options'][option_id]['prompt']}:",
                        initialvalue=current_value)
                    
                    if new_value is not None:  # User didn't cancel
                        self.config[option_id] = new_value
                        # Update the tree display
                        self.tree.item(item, values=(option_id, new_value))
                        # Update the details view
                        self.on_tree_select(None)
                    break
    
    def on_build_kernel(self):
        if not self.save_config():
            return
            
        # Disable buttons during build
        self.build_button.config(state=tk.DISABLED)
        self.clean_button.config(state=tk.DISABLED)
        self.save_button.config(state=tk.DISABLED)
        
        # Create a new window for build output
        build_win = tk.Toplevel(self.root)
        build_win.title("Building Kernel...")
        build_win.geometry("800x600")
        
        text = scrolledtext.ScrolledText(build_win, wrap=tk.WORD)
        text.pack(expand=True, fill='both', padx=5, pady=5)
        
        def update_output(process):
            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    text.insert(tk.END, output)
                    text.see(tk.END)
                    text.update_idletasks()
            
            process.poll()
            if process.returncode == 0:
                text.insert(tk.END, "\nBuild completed successfully!\n")
            else:
                text.insert(tk.END, f"\nBuild failed with return code {process.returncode}\n")
            
            # Re-enable buttons
            self.build_button.config(state=tk.NORMAL)
            self.clean_button.config(state=tk.NORMAL)
            self.save_button.config(state=tk.NORMAL)
            
            # Add a close button
            close_btn = ttk.Button(build_win, text="Close", command=build_win.destroy)
            close_btn.pack(pady=5)
        
        try:
            # Start the build process
            process = subprocess.Popen(
                ["make", "-j4"],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )
            
            # Start a thread to update the output
            import threading
            thread = threading.Thread(target=update_output, args=(process,), daemon=True)
            thread.start()
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to start build: {e}")
            self.build_button.config(state=tk.NORMAL)
            self.clean_button.config(state=tk.NORMAL)
            self.save_button.config(state=tk.NORMAL)
    
    def on_clean_build(self):
        if not messagebox.askyesno("Confirm", "This will clean all build artifacts. Continue?"):
            return
            
        # Disable buttons during clean
        self.build_button.config(state=tk.DISABLED)
        self.clean_button.config(state=tk.DISABLED)
        self.save_button.config(state=tk.DISABLED)
        
        # Create a new window for clean output
        clean_win = tk.Toplevel(self.root)
        clean_win.title("Cleaning Build...")
        clean_win.geometry("600x400")
        
        text = scrolledtext.ScrolledText(clean_win, wrap=tk.WORD)
        text.pack(expand=True, fill='both', padx=5, pady=5)
        text.insert(tk.END, "Cleaning build artifacts...\n")
        
        def update_output(process):
            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    text.insert(tk.END, output)
                    text.see(tk.END)
                    text.update_idletasks()
            
            process.poll()
            if process.returncode == 0:
                text.insert(tk.END, "\nClean completed successfully!\n")
            else:
                text.insert(tk.END, f"\nClean failed with return code {process.returncode}\n")
            
            # Re-enable buttons
            self.build_button.config(state=tk.NORMAL)
            self.clean_button.config(state=tk.NORMAL)
            self.save_button.config(state=tk.NORMAL)
            
            # Add a close button
            close_btn = ttk.Button(clean_win, text="Close", command=clean_win.destroy)
            close_btn.pack(pady=5)
        
        try:
            # Start the clean process
            process = subprocess.Popen(
                ["make", "clean"],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )
            
            # Start a thread to update the output
            import threading
            thread = threading.Thread(target=update_output, args=(process,), daemon=True)
            thread.start()
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to clean: {e}")
            self.build_button.config(state=tk.NORMAL)
            self.clean_button.config(state=tk.NORMAL)
            self.save_button.config(state=tk.NORMAL)
    
    def setup_ui(self):
        # Configure style
        style = ttk.Style()
        style.configure("Treeview", rowheight=25)
        style.configure("TButton", padding=5)
        
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(expand=True, fill='both')
        
        # Header
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill='x', pady=(0, 10))
        
        ttk.Label(header_frame, text=self.kernel_version, font=('Helvetica', 14, 'bold')).pack(side='left')
        
        # Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill='x', pady=(0, 10))
        
        self.save_button = ttk.Button(button_frame, text="Save Configuration", command=self.save_config)
        self.save_button.pack(side='left', padx=5)
        
        self.build_button = ttk.Button(button_frame, text="Build Kernel", command=self.on_build_kernel)
        self.build_button.pack(side='left', padx=5)
        
        self.clean_button = ttk.Button(button_frame, text="Clean Build", command=self.on_clean_build)
        self.clean_button.pack(side='left', padx=5)
        
        # Paned window for tree and details
        paned = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned.pack(expand=True, fill='both')
        
        # Left pane - Treeview for options
        tree_frame = ttk.Frame(paned, padding=5)
        paned.add(tree_frame, weight=1)
        
        # Add search frame
        search_frame = ttk.Frame(tree_frame)
        search_frame.pack(fill='x', pady=(0, 5))
        
        ttk.Label(search_frame, text="Search:").pack(side='left')
        search_var = tk.StringVar()
        search_entry = ttk.Entry(search_frame, textvariable=search_var)
        search_entry.pack(side='left', fill='x', expand=True, padx=5)
        
        # Create treeview with scrollbar
        tree_scroll = ttk.Scrollbar(tree_frame)
        tree_scroll.pack(side='right', fill='y')
        
        self.tree = ttk.Treeview(tree_frame, yscrollcommand=tree_scroll.set, 
                               selectmode='browse', height=20)
        tree_scroll.config(command=self.tree.yview)
        self.tree.pack(expand=True, fill='both')
        
        # Configure tree columns
        self.tree["columns"] = ("option", "value")
        self.tree.column("#0", width=300, minwidth=200, stretch=tk.YES)
        self.tree.column("option", width=0, stretch=tk.NO)  # Hidden column for option ID
        self.tree.column("value", width=50, minwidth=30, anchor='center')
        
        self.tree.heading("#0", text="Option")
        self.tree.heading("option", text="")
        self.tree.heading("value", text="Value")
        
        # Right pane - Details
        details_frame = ttk.Frame(paned, padding=5)
        paned.add(details_frame, weight=2)
        
        ttk.Label(details_frame, text="Option Details", font=('Helvetica', 10, 'bold')).pack(anchor='w')
        
        # Add a text widget for details
        self.details_text = scrolledtext.ScrolledText(details_frame, wrap=tk.WORD, height=20,
                                                     font=('Courier', 10), state=tk.DISABLED)
        self.details_text.pack(expand=True, fill='both')
        
        # Button frame for option actions
        option_btn_frame = ttk.Frame(details_frame)
        option_btn_frame.pack(fill='x', pady=(5, 0))
        
        self.toggle_btn = ttk.Button(option_btn_frame, text="Toggle Option (Y/N)", 
                                   command=self.on_toggle_option)
        self.toggle_btn.pack(side='left', padx=2)
        
        self.edit_btn = ttk.Button(option_btn_frame, text="Edit Value", 
                                 command=self.on_edit_string)
        self.edit_btn.pack(side='left', padx=2)
        
        # Status bar
        self.status_var = tk.StringVar()
        self.status_var.set("Ready")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN, 
                             anchor=tk.W, padding=3)
        status_bar.pack(fill='x', pady=(5, 0))
        
        # Bind events
        self.tree.bind('<<TreeviewSelect>>', self.on_tree_select)
        self.tree.bind('<Double-1>', lambda e: self.on_toggle_option())
        
        # Set initial focus
        self.tree.focus_set()
        
        # Auto-expand all categories
        def expand_categories():
            for item in self.tree.get_children():
                self.tree.item(item, open=True)
        
        self.root.after(100, expand_categories)

def main():
    root = tk.Tk()
    app = KernelConfigGUI(root)
    
    # Center the window
    window_width = 1000
    window_height = 700
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    center_x = int(screen_width/2 - window_width/2)
    center_y = int(screen_height/2 - window_height/2)
    root.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
    
    # Set application icon if available
    try:
        root.iconbitmap('kernel.ico')  # You can add an icon file if desired
    except:
        pass
    
    root.mainloop()

if __name__ == "__main__":
    main()
